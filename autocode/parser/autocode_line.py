# ast code will be imported here


# Begin -- grammar generated by Yapps
import sys, re
from yapps import runtime

class AutocodeLineParserScanner(runtime.Scanner):
    patterns = [
        ("','", re.compile(',')),
        ('\\s', re.compile('\\s')),
        ('EOL', re.compile('$')),
        ('index', re.compile('n[0-9][0-9]?')),
        ('function', re.compile('MOD')),
        ('plus', re.compile('\\+')),
        ('var', re.compile('v')),
        ('prt', re.compile('PRINT')),
        ('tape', re.compile('TAPE')),
        ('spec', re.compile('[0-9]{4}')),
        ('label', re.compile('[1-9][0-9]?\\)')),
        ('directive', re.compile('D|T')),
        ('op', re.compile('\\+|-|x|/')),
        ('integer', re.compile('[0-9]{1,4}')),
        ('float', re.compile('[0-9]*\\.[0-9]*')),
        ('end', re.compile('\\^0')),
        ('gets', re.compile('=')),
        ('negate', re.compile('-')),
        ('star', re.compile('\\*')),
        ('lparen', re.compile('\\(')),
        ('rparen', re.compile('\\)')),
    ]
    def __init__(self, str,*args,**kw):
        runtime.Scanner.__init__(self,None,{'\\s':None,},str,*args,**kw)

class AutocodeLineParser(runtime.Parser):
    Context = runtime.Context
    def line(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'line', [])
        _token = self._peek('directive', 'label', 'end', 'prt', 'tape', 'index', 'var', context=_context)
        if _token == 'directive':
            directive = self._scan('directive', context=_context)
        elif _token == 'label':
            label = self._scan('label', context=_context)
            statement = self.statement(_context)
        elif _token != 'end':
            statement = self.statement(_context)
        else: # == 'end'
            end = self._scan('end', context=_context)
        EOL = self._scan('EOL', context=_context)
        return 'OK'

    def statement(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'statement', [])
        _token = self._peek('prt', 'tape', 'index', 'var', context=_context)
        if _token not in ['prt', 'tape']:
            assignment = self.assignment(_context)
        elif _token == 'prt':
            print_statement = self.print_statement(_context)
        else: # == 'tape'
            tape_statement = self.tape_statement(_context)

    def print_statement(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'print_statement', [])
        prt = self._scan('prt', context=_context)
        _token = self._peek('index', 'var', context=_context)
        if _token == 'index':
            index = self._scan('index', context=_context)
        else: # == 'var'
            variable = self.variable(_context)
        self._scan("','", context=_context)
        _token = self._peek('spec', 'index', context=_context)
        if _token == 'spec':
            spec = self._scan('spec', context=_context)
        else: # == 'index'
            index = self._scan('index', context=_context)

    def tape_statement(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'tape_statement', [])
        tape = self._scan('tape', context=_context)

    def assignment(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'assignment', [])
        _token = self._peek('index', 'var', context=_context)
        if _token == 'index':
            int_assignment = self.int_assignment(_context)
        else: # == 'var'
            var_assignment = self.var_assignment(_context)

    def variable(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'variable', [])
        var = self._scan('var', context=_context)
        _token = self._peek('integer', 'index', 'lparen', context=_context)
        if _token == 'integer':
            integer = self._scan('integer', context=_context)
        elif _token == 'index':
            index = self._scan('index', context=_context)
        else: # == 'lparen'
            modifier = self.modifier(_context)

    def modifier(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'modifier', [])
        lparen = self._scan('lparen', context=_context)
        if self._peek('negate', 'integer', context=_context) == 'negate':
            negate = self._scan('negate', context=_context)
        integer = self._scan('integer', context=_context)
        plus = self._scan('plus', context=_context)
        index = self._scan('index', context=_context)
        rparen = self._scan('rparen', context=_context)

    def int_assignment(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'int_assignment', [])
        index = self._scan('index', context=_context)
        gets = self._scan('gets', context=_context)
        _token = self._peek('tape', 'negate', 'integer', 'index', context=_context)
        if _token == 'tape':
            tape_spec = self.tape_spec(_context)
        else: # in ['negate', 'integer', 'index']
            int_expression = self.int_expression(_context)

    def var_assignment(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'var_assignment', [])
        variable = self.variable(_context)
        gets = self._scan('gets', context=_context)
        _token = self._peek('tape', 'negate', 'float', 'var', 'function', context=_context)
        if _token == 'tape':
            tape_spec = self.tape_spec(_context)
        else: # in ['negate', 'float', 'var', 'function']
            var_expression = self.var_expression(_context)

    def tape_spec(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'tape_spec', [])
        tape = self._scan('tape', context=_context)
        if self._peek('index', 'star', 'gets', "','", 'op', 'EOL', context=_context) in ['index', 'star']:
            tape_qualifier = self.tape_qualifier(_context)

    def tape_qualifier(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'tape_qualifier', [])
        _token = self._peek('index', 'star', context=_context)
        if _token == 'index':
            index = self._scan('index', context=_context)
        else: # == 'star'
            star = self._scan('star', context=_context)

    def var_expression(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'var_expression', [])
        _token = self._peek('negate', 'float', 'var', 'function', context=_context)
        if _token not in ['var', 'function']:
            if self._peek('negate', 'float', context=_context) == 'negate':
                negate = self._scan('negate', context=_context)
            float = self._scan('float', context=_context)
        elif _token == 'var':
            variable = self.variable(_context)
            if self._peek('op', 'gets', "','", 'EOL', context=_context) == 'op':
                var_tail = self.var_tail(_context)
        else: # == 'function'
            function = self._scan('function', context=_context)
            _token = self._peek('float', 'var', context=_context)
            if _token == 'float':
                float = self._scan('float', context=_context)
            else: # == 'var'
                variable = self.variable(_context)

    def var_tail(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'var_tail', [])
        op = self._scan('op', context=_context)
        _token = self._peek('integer', 'float', 'var', context=_context)
        if _token == 'integer':
            integer = self._scan('integer', context=_context)
        elif _token == 'float':
            float = self._scan('float', context=_context)
        else: # == 'var'
            variable = self.variable(_context)

    def int_expression(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'int_expression', [])
        _token = self._peek('negate', 'integer', 'index', context=_context)
        if _token != 'index':
            if self._peek('negate', 'integer', context=_context) == 'negate':
                negate = self._scan('negate', context=_context)
            integer = self._scan('integer', context=_context)
        else: # == 'index'
            index = self._scan('index', context=_context)
            if self._peek('op', 'star', 'gets', 'EOL', "','", context=_context) in ['op', 'star']:
                int_tail = self.int_tail(_context)

    def int_op(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'int_op', [])
        _token = self._peek('op', 'star', context=_context)
        if _token == 'op':
            op = self._scan('op', context=_context)
        else: # == 'star'
            star = self._scan('star', context=_context)

    def int_tail(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'int_tail', [])
        int_op = self.int_op(_context)
        _token = self._peek('index', 'integer', context=_context)
        if _token == 'index':
            index = self._scan('index', context=_context)
        else: # == 'integer'
            integer = self._scan('integer', context=_context)


def parse(rule, text):
    P = AutocodeLineParser(AutocodeLineParserScanner(text))
    return runtime.wrap_error_reporter(P, rule)

if __name__ == '__main__':
    from sys import argv, stdin
    if len(argv) >= 2:
        if len(argv) >= 3:
            f = open(argv[2],'r')
        else:
            f = stdin
        print parse(argv[1], f.read())
    else: print >>sys.stderr, 'Args:  <rule> [<filename>]'
# End -- grammar generated by Yapps
