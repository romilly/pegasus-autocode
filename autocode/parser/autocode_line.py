# ast code will be imported here


# Begin -- grammar generated by Yapps
import sys, re
from yapps import runtime

class AutocodeLineParserScanner(runtime.Scanner):
    patterns = [
        ("','", re.compile(',')),
        ('\\s', re.compile('\\s')),
        ('EOL', re.compile('$')),
        ('index', re.compile('n[0-9][0-9]?')),
        ('mod', re.compile('MOD')),
        ('function', re.compile('MOD|INT|FRAC|SQRT|SIN|COS|TAN|CSC|SEC|COT|ARCSIN|ARCCOS|ARCTAN|LOG|EXPM|EXP')),
        ('plus', re.compile('\\+')),
        ('var', re.compile('v')),
        ('special_printing', re.compile('XP|X|SP|S')),
        ('prt', re.compile('PRINT')),
        ('tapes', re.compile('TAPE[B]?')),
        ('tape', re.compile('TAPE')),
        ('spec', re.compile('[0-9]{4}')),
        ('label', re.compile('[1-9][0-9]?\\)')),
        ('negate', re.compile('-')),
        ('div', re.compile('/')),
        ('op', re.compile('\\+|-|x|/')),
        ('integer', re.compile('[0-9]{1,4}')),
        ('float', re.compile('[0-9]*\\.[0-9]*')),
        ('gets', re.compile('=')),
        ('star', re.compile('\\*')),
        ('lparen', re.compile('\\(')),
        ('rparen', re.compile('\\)')),
        ('goto', re.compile('\\^')),
        ('stop', re.compile('STOP')),
        ('compare', re.compile('>=|>|\\=\\*|\\=|=\\*|=')),
    ]
    def __init__(self, str,*args,**kw):
        runtime.Scanner.__init__(self,None,{'\\s':None,},str,*args,**kw)

class AutocodeLineParser(runtime.Parser):
    Context = runtime.Context
    def line(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'line', [])
        if self._peek('lparen', 'special_printing', 'label', 'stop', 'prt', 'tape', 'goto', 'index', 'var', context=_context) == 'lparen':
            lparen = self._scan('lparen', context=_context)
        if self._peek('special_printing', 'label', 'stop', 'prt', 'tape', 'goto', 'index', 'var', context=_context) == 'special_printing':
            special_printing = self._scan('special_printing', context=_context)
        _token = self._peek('label', 'stop', 'prt', 'tape', 'goto', 'index', 'var', context=_context)
        if _token == 'label':
            label = self._scan('label', context=_context)
            statement = self.statement(_context)
        else: # in ['stop', 'prt', 'tape', 'goto', 'index', 'var']
            statement = self.statement(_context)
        if self._peek('rparen', 'EOL', context=_context) == 'rparen':
            rparen = self._scan('rparen', context=_context)
        EOL = self._scan('EOL', context=_context)
        return 'OK'

    def statement(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'statement', [])
        _token = self._peek('stop', 'prt', 'tape', 'goto', 'index', 'var', context=_context)
        if _token in ['index', 'var']:
            assignment = self.assignment(_context)
        elif _token == 'prt':
            print_statement = self.print_statement(_context)
        elif _token == 'tape':
            tape_statement = self.tape_statement(_context)
        elif _token == 'stop':
            stop = self._scan('stop', context=_context)
        else: # == 'goto'
            jump = self.jump(_context)

    def print_statement(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'print_statement', [])
        prt = self._scan('prt', context=_context)
        _token = self._peek('index', 'var', context=_context)
        if _token == 'index':
            index = self._scan('index', context=_context)
        else: # == 'var'
            variable = self.variable(_context)
        self._scan("','", context=_context)
        _token = self._peek('spec', 'index', context=_context)
        if _token == 'spec':
            spec = self._scan('spec', context=_context)
        else: # == 'index'
            index = self._scan('index', context=_context)

    def tape_statement(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'tape_statement', [])
        tape = self._scan('tape', context=_context)

    def assignment(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'assignment', [])
        _token = self._peek('index', 'var', context=_context)
        if _token == 'index':
            int_assignment = self.int_assignment(_context)
        else: # == 'var'
            var_assignment = self.var_assignment(_context)

    def variable(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'variable', [])
        var = self._scan('var', context=_context)
        _token = self._peek('integer', 'index', 'lparen', context=_context)
        if _token == 'integer':
            integer = self._scan('integer', context=_context)
        elif _token == 'index':
            index = self._scan('index', context=_context)
        else: # == 'lparen'
            modifier = self.modifier(_context)

    def modifier(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'modifier', [])
        lparen = self._scan('lparen', context=_context)
        if self._peek('negate', 'integer', context=_context) == 'negate':
            negate = self._scan('negate', context=_context)
        integer = self._scan('integer', context=_context)
        plus = self._scan('plus', context=_context)
        index = self._scan('index', context=_context)
        rparen = self._scan('rparen', context=_context)

    def int_assignment(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'int_assignment', [])
        index = self._scan('index', context=_context)
        gets = self._scan('gets', context=_context)
        _token = self._peek('tapes', 'index', 'negate', 'integer', 'mod', 'var', context=_context)
        if _token == 'tapes':
            tape_spec = self.tape_spec(_context)
        else: # in ['index', 'negate', 'integer', 'mod', 'var']
            int_expression = self.int_expression(_context)

    def var_assignment(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'var_assignment', [])
        variable = self.variable(_context)
        gets = self._scan('gets', context=_context)
        _token = self._peek('tapes', 'var', 'negate', 'float', 'function', 'index', 'integer', context=_context)
        if _token == 'tapes':
            tape_spec = self.tape_spec(_context)
        else:
            var_expression = self.var_expression(_context)

    def tape_spec(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'tape_spec', [])
        tapes = self._scan('tapes', context=_context)
        if self._peek('index', 'star', 'gets', 'div', "','", 'op', 'compare', 'rparen', 'EOL', context=_context) in ['index', 'star']:
            tape_qualifier = self.tape_qualifier(_context)

    def tape_qualifier(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'tape_qualifier', [])
        _token = self._peek('index', 'star', context=_context)
        if _token == 'index':
            index = self._scan('index', context=_context)
        else: # == 'star'
            star = self._scan('star', context=_context)

    def var_expression(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'var_expression', [])
        _token = self._peek('var', 'negate', 'float', 'function', 'index', 'integer', context=_context)
        if _token == 'var':
            variable = self.variable(_context)
            if self._peek('op', 'gets', 'div', "','", 'compare', 'rparen', 'EOL', context=_context) == 'op':
                var_tail = self.var_tail(_context)
        else: # in ['negate', 'float', 'function', 'index', 'integer']
            if self._peek('negate', 'float', 'function', 'index', 'integer', context=_context) == 'negate':
                negate = self._scan('negate', context=_context)
            _token = self._peek('float', 'function', 'index', 'integer', context=_context)
            if _token not in ['float', 'function']:
                int_val = self.int_val(_context)
                if self._peek('div', 'compare', "','", 'gets', 'op', 'rparen', 'EOL', context=_context) == 'div':
                    div = self._scan('div', context=_context)
                    int_val = self.int_val(_context)
            elif _token == 'float':
                float = self._scan('float', context=_context)
            else: # == 'function'
                function = self._scan('function', context=_context)
                var_val = self.var_val(_context)

    def int_val(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'int_val', [])
        _token = self._peek('index', 'integer', context=_context)
        if _token == 'index':
            index = self._scan('index', context=_context)
        else: # == 'integer'
            integer = self._scan('integer', context=_context)

    def var_tail(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'var_tail', [])
        op = self._scan('op', context=_context)
        _token = self._peek('integer', 'float', 'var', context=_context)
        if _token == 'integer':
            integer = self._scan('integer', context=_context)
        elif _token == 'float':
            float = self._scan('float', context=_context)
        else: # == 'var'
            variable = self.variable(_context)

    def var_val(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'var_val', [])
        _token = self._peek('var', 'float', context=_context)
        if _token == 'var':
            variable = self.variable(_context)
        else: # == 'float'
            float = self._scan('float', context=_context)

    def int_expression(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'int_expression', [])
        _token = self._peek('index', 'negate', 'integer', 'mod', 'var', context=_context)
        if _token == 'index':
            index = self._scan('index', context=_context)
            if self._peek('op', 'star', 'gets', "','", 'div', 'compare', 'rparen', 'EOL', context=_context) in ['op', 'star']:
                int_tail = self.int_tail(_context)
        else: # in ['negate', 'integer', 'mod', 'var']
            if self._peek('negate', 'integer', 'mod', 'var', context=_context) == 'negate':
                negate = self._scan('negate', context=_context)
            _token = self._peek('integer', 'mod', 'var', context=_context)
            if _token == 'integer':
                integer = self._scan('integer', context=_context)
            elif _token == 'mod':
                mod = self._scan('mod', context=_context)
                _token = self._peek('var', 'index', context=_context)
                if _token == 'var':
                    variable = self.variable(_context)
                else: # == 'index'
                    index = self._scan('index', context=_context)
            else: # == 'var'
                variable = self.variable(_context)

    def int_op(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'int_op', [])
        _token = self._peek('op', 'star', context=_context)
        if _token == 'op':
            op = self._scan('op', context=_context)
        else: # == 'star'
            star = self._scan('star', context=_context)

    def int_tail(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'int_tail', [])
        int_op = self.int_op(_context)
        _token = self._peek('index', 'integer', context=_context)
        if _token == 'index':
            index = self._scan('index', context=_context)
        else: # == 'integer'
            integer = self._scan('integer', context=_context)

    def jump(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'jump', [])
        goto = self._scan('goto', context=_context)
        _token = self._peek('index', 'integer', 'lparen', context=_context)
        if _token != 'lparen':
            int_val = self.int_val(_context)
        else: # == 'lparen'
            modifier = self.modifier(_context)
        if self._peek("','", 'gets', 'compare', 'div', 'op', 'rparen', 'EOL', context=_context) == "','":
            self._scan("','", context=_context)
            condition = self.condition(_context)

    def condition(self, _parent=None):
        _context = self.Context(_parent, self._scanner, 'condition', [])
        if self._peek('negate', 'var', 'float', 'index', 'integer', context=_context) == 'negate':
            negate = self._scan('negate', context=_context)
        _token = self._peek('var', 'float', 'index', 'integer', context=_context)
        if _token not in ['index', 'integer']:
            var_val = self.var_val(_context)
            compare = self._scan('compare', context=_context)
            if self._peek('negate', 'var', 'float', context=_context) == 'negate':
                negate = self._scan('negate', context=_context)
            var_val = self.var_val(_context)
        else: # in ['index', 'integer']
            int_val = self.int_val(_context)
            compare = self._scan('compare', context=_context)
            if self._peek('negate', 'index', 'integer', context=_context) == 'negate':
                negate = self._scan('negate', context=_context)
            int_val = self.int_val(_context)


def parse(rule, text):
    P = AutocodeLineParser(AutocodeLineParserScanner(text))
    return runtime.wrap_error_reporter(P, rule)

if __name__ == '__main__':
    from sys import argv, stdin
    if len(argv) >= 2:
        if len(argv) >= 3:
            f = open(argv[2],'r')
        else:
            f = stdin
        print parse(argv[1], f.read())
    else: print >>sys.stderr, 'Args:  <rule> [<filename>]'
# End -- grammar generated by Yapps
